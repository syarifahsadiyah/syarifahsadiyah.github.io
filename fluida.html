
<!Doctype: HTML w/ Processing>

<html>

  <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <title>FLUIDA</title>
      <script type="text/javascript" src="js/processing.js"></script>
  </head>
  
  <body>
    
    <script type="text/processing">
    
      int Nx = 192;
int Ny = 108;
int cell_size = 10;
int b = 0;//still undecidet
float dt = 0.2f;
float diff = 0;//density diffusion
float visc = 0.00001;//speed diffusion
int iter = 20;//diffusion sampling
//Brush config
float B_dense = 100;
float B_dense_size = 300;
float B_velocity = 2;
float B_velocity_size = 12;


float t = 0;
float angle = 0;
int size = (Nx+2)*(Ny+2);
float[] dens = new float[size];
float[] s = new float[size];
float[] Vx = new float[size];
float[] Vy = new float[size];
float[] Vx0 = new float[size];
float[] Vy0 = new float[size];

ArrayList<Particle> particles = new ArrayList<Particle>();

public void setup(){
  fullScreen();
  colorMode(HSB, 360, 100, 100, 100);
  background(0);
}

void draw(){
  fill(0, 1);
  noStroke();  
  rect(0, 0, width, height);
  //background(0);
  //draw and user input    
  for(int i = 0; i <= Nx; i++){
    for(int j=0; j <= Ny; j++){
      float cx = i*width/Nx;//grid address to position
      float cy = j*height/Ny;
      if(mousePressed){
        dens[IX(i, j)] += constrain(1-dist(mouseX, mouseY, cx, cy)/B_dense_size, 0, 1)*B_dense;
        Vx[IX(i, j)] += constrain(1-dist(mouseX, mouseY, cx, cy)/B_velocity_size, 0, 0.1)*cos(angle)*B_velocity;
        Vy[IX(i, j)] += constrain(1-dist(mouseX, mouseY, cx, cy)/B_velocity_size, 0, 0.1)*sin(angle)*B_velocity;
      }
      //fill((dens[IX(i, j)]/10)%360, 100, dens[IX(i, j)]/5);
      //rect(cx, cy, width/Nx, -height/Ny);
    }
  }
  //draw Cursor
  stroke(360, 50);
  strokeWeight(3);
  line(mouseX, mouseY, mouseX+cos(angle)*50.0, mouseY+sin(angle)*50.0);
  //update Fluid
  if(mousePressed){
    for(int i = 0; i < 100; i++){
      particles.add(new Particle(new PVector(mouseX+random(-B_velocity_size, B_velocity_size), mouseY+random(-B_velocity_size, B_velocity_size))));
    }
  }
  noStroke();
  for(Particle particle : particles){
    int index = IX(int(particle.pos.x*Nx/width),int(particle.pos.y*Ny/height));
    float tVx = Vx[index];
    float tVy = Vy[index];
    particle.pos.add(tVx*300, tVy*300);
    fill(sqrt(tVx*tVx+tVy*tVy)*2000, 100, 100, 50);
    rect(particle.pos.x, particle.pos.y, 5, 5);
  }
  fluid_step();
}

void mouseWheel(MouseEvent e ){
  angle += e.getAmount()*0.1;
}

void keyPressed(){
  if(key=='r'){
    for(int i = 0; i<size; i++) dens[i] = 0;
    particles = new ArrayList<Particle>();
    background(0);
  }
}

class Particle{
  Particle(PVector pos){
    this.pos = pos;
  }
  PVector pos;
}

void fluid_step(){
  vel_step(Vx, Vy, Vx0, Vy0, visc, dt);
  diffuse(0, s, dens, diff, dt);
  advect(0, dens, s, Vx, Vy, dt);
}

void vel_step(float[] Vx, float []Vy, float[] Vx0, float[] Vy0, float visc, float dt){//visc is diffusion in speed
  diffuse(1, Vx0, Vx, visc, dt);//omit SWAP
  diffuse(2, Vy0, Vy, visc, dt);//Two times omit SWAP is the same as doing Nothing
  project(Vx0, Vy0, Vx, Vy);//However, each time SWAP is omitted, the previous and current are reversed
  advect(1, Vx, Vx0, Vx0, Vy0, dt);//omit SWAP
  advect(2, Vy, Vy0, Vx0, Vy0, dt);
  project(Vx, Vy, Vx0, Vy0);
}


int IX(int i, int j){
  i = constrain(i, 0, Nx-1);
  j = constrain(j, 0, Ny-1);
  return i + (j * Nx);
}

void add_source(float[] x, float[] s, float dt){
  for(int i = 0; i<size; i++) x[i] += dt*s[i];
}

void diffuse (int b, float[] x, float[] x0, float diff, float dt) {
  float a = dt * diff * Nx * Ny;
  lin_solve(b, x, x0, a, 1 + 4 * a);//Which is correct 4 or 6
}

void lin_solve(int b, float[] x, float[] x0, float a, float c) {
  float cRecip = 1.0 / c;
  for (int k = 0; k < iter; k++) {
    for (int i = 1; i <= Nx; i++) {
      for (int j = 1; j <= Ny; j++) {
        x[IX(i, j)] = (x0[IX(i, j)]+ a*(x[IX(i+1, j)]+x[IX(i-1, j)]+x[IX(i, j+1)]+x[IX(i, j-1)])) * cRecip;
      }
    }
    set_bnd(b, x);
  }
}

void project (float[] Vx, float[] Vy, float[] Vx0, float[] Vy0){
  float h = 1.0/ (float)Ny;
  for(int i = 1; i <= Nx; i++){
    for(int j = 1; j <= Ny; j++){
      Vy0[IX(i, j)] = -0.5*h*(Vx[IX(i+1, j)]-Vx[IX(i-1, j)]+Vy[IX(i, j+1)]-Vy[IX(i, j-1)]);
      Vx0[IX(i, j)] = 0;
    }
  }
  set_bnd(0, Vy0); set_bnd(0, Vx0);
  lin_solve(0, Vx0, Vy0, 1, 4);//which is correct 6 or 4
  for(int i = 1; i < Nx - 1; i++){
    for(int j = 1; j < Ny - 1; j++){
      Vx[IX(i, j)] -= 0.5*(Vx0[IX(i+1, j)]-Vx0[IX(i-1, j)])/h;
      Vy[IX(i, j)] -= 0.5*(Vx0[IX(i, j+1)]-Vx0[IX(i, j-1)])/h;
    }
  }
  set_bnd(1, Vx); set_bnd(2, Vy);
}

void advect(int b, float[] d, float[] d0, float[] Vx, float[] Vy, float dt){
  int i, j, i0, j0, i1, j1;
  float x, y, s0, t0, s1, t1;
  for(i = 1; i <= Nx; i++){
    for(j = 1; j <= Ny; j++){
      x = (float)i-dt*Nx*Vx[IX(i, j)]; y = (float)j-dt*Ny*Vy[IX(i, j)];
      x = constrain(x, 0.5, (float)Nx+0.5); i0 = floor(x); i1 = i0+1;
      y = constrain(y, 0.5, (float)Ny+0.5); j0 = floor(y); j1 = j0+1;
      s1 = x-(float)i0; s0 = 1.0-s1; t1 = y-(float)j0; t0 = 1-t1;
      d[IX(i, j)] = s0*(t0*d0[IX(i0, j0)]+t1*d0[IX(i0, j1)])+s1*(t0*d0[IX(i1, j0)]+t1*d0[IX(i1, j1)]);
    }
  }
  set_bnd(b, d);
}

void set_bnd(int b, float[] x) {
  for (int i = 1; i < Nx - 1; i++) {
    x[IX(i, 0  )] = b == 2 ? -x[IX(i, 1  )] : x[IX(i, 1 )];
    x[IX(i, Ny-1)] = b == 2 ? -x[IX(i, Ny-2)] : x[IX(i, Ny-2)];
  }
  for (int j = 1; j < Ny - 1; j++) {
    x[IX(0, j)] = b == 1 ? -x[IX(1, j)] : x[IX(1, j)];
    x[IX(Nx-1, j)] = b == 1 ? -x[IX(Nx-2, j)] : x[IX(Nx-2, j)];
  }

  x[IX(0, 0)] = 0.5f * (x[IX(1, 0)] + x[IX(0, 1)]);
  x[IX(0, Ny-1)] = 0.5f * (x[IX(1, Ny-1)] + x[IX(0, Ny-2)]);
  x[IX(Nx-1, 0)] = 0.5f * (x[IX(Nx-2, 0)] + x[IX(Nx-1, 1)]);
  x[IX(Nx-1, Ny-1)] = 0.5f * (x[IX(Nx-2, Ny-1)] + x[IX(Nx-1, Ny-2)]);
}

    </script>
    <canvas id="sketch" style="border: 1px solid black;"></canvas>
    
  </body>
  
</html>
